services:
  api:
    # Собираю API из Dockerfile (наш multi-stage)
    build:
      context: .
      dockerfile: src/Weather.Api/Dockerfile
    # Пробрасываю порт хоста -> внутрь контейнера (Kestrel слушает :8080)
    ports:
      - "8080:8080"
    # Окружение берётся из .env + эти доп.переменные
    depends_on:
      # Жду готовности Redis по healthcheck, прежде чем стартовать API
      redis:
        condition: service_healthy
    env_file:
      - .env
    restart: unless-stopped # рестарт при падении, но не при остановке вручную

  redis:
    image: redis:7-alpine
    # Ограничиваю память Redis и включаю вытеснение allkeys-lru (удобно для кэша)
    command:
      [
        "redis-server",
        "--maxmemory",
        "256mb",
        "--maxmemory-policy",
        "allkeys-lru",
      ]
    # Порт наружу — чтобы можно было подключиться redis-cli/GUI при отладке
    ports:
      - "6379:6379"
    # Простейший healthcheck — ждём PONG
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "redis-cli --raw -h 127.0.0.1 -p 6379 ping | grep -q PONG",
        ]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 5s
    restart: unless-stopped
    volumes:
      - redis-data:/data
volumes:
  redis-data: {}
