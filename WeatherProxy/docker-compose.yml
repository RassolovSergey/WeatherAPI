services:
  api:
    # Собираю API из Dockerfile (наш multi-stage)
    build:
      context: .
      dockerfile: src/Weather.Api/Dockerfile
    # Пробрасываю порт хоста -> внутрь контейнера (Kestrel слушает :8080)
    ports:
      - "8080:8080"
    # Окружение берётся из .env + эти доп.переменные
    environment:
      ASPNETCORE_ENVIRONMENT: ${ASPNETCORE_ENVIRONMENT} # Development → включит Swagger
      WEATHERAPI__BASEURL: ${WEATHERAPI__BASEURL} # базовый URL провайдера
      WEATHERAPI__APIKEY: ${WEATHERAPI__APIKEY} # ключ провайдера (заполни позже)
      REDIS__CONNECTIONSTRING: ${REDIS__CONNECTIONSTRING} # строка подключения к Redis
    depends_on:
      # Жду готовности Redis по healthcheck, прежде чем стартовать API
      redis:
        condition: service_healthy

  redis:
    image: redis:7-alpine
    # Ограничиваю память Redis и включаю вытеснение allkeys-lru (удобно для кэша)
    command:
      [
        "redis-server",
        "--maxmemory",
        "256mb",
        "--maxmemory-policy",
        "allkeys-lru",
      ]
    # Порт наружу — чтобы можно было подключиться redis-cli/GUI при отладке
    ports:
      - "6379:6379"
    # Простейший healthcheck — ждём PONG
    healthcheck:
      test: ["CMD-SHELL", "redis-cli --raw -h 127.0.0.1 -p 6379 ping | grep -q PONG"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 5s
